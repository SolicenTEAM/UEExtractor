# Моё исследование как взаимодействуют байты в файлах `.locres` - Unreal Engine
> Всё ниже описанное не является истинной в последней инстанции, и может быть неправильно понятой мыслью или неверными размышлениями, моими лично и только моими - Denis Solicen.

## Чуть ближе к истине
`0E 14 74 75 67 4A 03 FC 4A 15 90 9D C3 37 7F 1B 01`

Проведя реверс-инжиниринг файла `.locres` я смог убедиться, что первые **17 байтов**, это заголовок файла который должен быть не изменным для определенного проекта, и у каждого проекта этот заголовок свой, его можно взять из файла `Engine.locres` или `.metaloc` из ресурсов игры.


`7F 00 00 00`

Следующие 4 байта, это смещение, и вот оно самое интересное, его я опишу чуть ниже, так как я нашел (создал) формулу по которой оно расчитывается.

### Смещение - Offset
Я не великий математик, поэтому описывать формулу какими-то заковыристыми путями не буду, и опишу её так, как я нашел.

Сразу скажу здесь `7F 00 00 00` смещение равняется = 127, я приведу в конце данного файла, полный небольшой открывок из байтов, что вы могли сами провести подобные исследования, а не слепо доверять мне.

Но приступим к формуле.

---

1. Подсчитываем байты от начала начала файла, до первых текстовых данных, пусть это будет наш '**X**' в этой формуле.
   ```
   0E 14 74 75 67 4A 03 FC 4A 15 90 9D C3 37 7F 1B 01 7F 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 02 00 00 00 21 00 00 00 46 45 44 39 31 32 42 44 34 44 34 31 41 37 34 36 33 46 46 44 38 32 42 42 45 31 36 35 42 44 45 32 00 CE 2E C3 F0 00 00 00 00 21 00 00 00 46 42 31 39 46 34 44 43 34 42 35 30 43 33 43 43 39 36 37 35 35 44 42 41 32 34 34 34 30 38 34 33 00 08 B6 A5 84 01 00 00 00 02 00 00 00 47 00 00 00
   ```
2. Затем, подсчитываем байты от 20 байта (не включительно) до определения начала текстовых данных: - это наш `Y`.
3. Затем самое легкое для мозга, подсчитываем количество хешей и умножаем на 32 (символов в одном хеше), получаем - `Q`
4. Рассчитываем, промежуточное число: `F = X - Q.`
5. Итого, смещение равно: `X - Y + F`.

- Иначе говоря, формула: `X - Y + (X - Q) = Offset`

---
Вы можете сами проверить и убедиться в этом, ну а я буду двигаться дальше по файлу.
### Определение строк
На позиции `34 байта` + `3 три` дополнительных, находит своё место число количества строк данных в файле, оно может быть закодировано как Int8, так и в Uint64, всё зависит от того сколько строк данных в файле.


> Я опустил некоторую информацию, так как она может варироваться от файла к файлу, однако в большинстве своем байты не описанные в порядке 32 байтов, просто нули `0x00`, и не важны для  информации, и её считывания.

### Текстовые данные
О сколько боли в этих словах, но пожалуй попробую рассказать свои дальнейшие исследования, на примере.

#### Пример 1
Допустим у нас есть строка: `Allows for opening and closing a "gate" to control the execution flow.` - она же в байтах: 
```
47 00 00 00 41 6C 6C 6F 77 73 20 66 6F 72 20 6F 70 65 6E 69 6E 67 20 61 6E 64 20 63 6C 6F 73 69 6E 67 20 61 20 22 67 61 74 65 22 20 74 6F 20 63 6F 6E 74 72 6F 6C 20 74 68 65 20 65 78 65 63 75 74 69 6F 6E 20 66 6C 6F 77 2E
```
При этом, первые четыре байта а именно `47 00 00 00` это разделитель и одновременно информация о количестве символов в строке, в этой их 71, а байт `0x47` в представлении Int8 и дает число **71**, уловили суть? Ах да, вы можете возразить: - *"Но ведь там же 70 символов, а не 71!"* - так то оно так, но, в байтовом представлении их именно **71**.  

#### Пример 2
Вот байты с 33 байта от начала:
```
00 02 00 00 00 21 00 00 00 46 45 44 39 31 32 42 44 34 44 34 31 41 37 34 36 33 46 46 44 38 32 42 42 45 31 36 35 42 44 45 32 00 CE 2E C3 F0 00 00
```
Здесь как мы уже выяснили в `34` байте и последующих за ним скрывается число строк в файле, нашем случае их две. Так как `0x02` дает именно число **2**.

Но, кроме этого мы видим сам хеш (**32 байта**) на позиции от `42` байта: 
```
46 45 44 39 31 32 42 44 34 44 34 31 41 37 34 36 33 46 46 44 38 32 42 42 45 31 36 35 42 44 45 32
```
Перед ним красуются еще 4 байта, это опять же разделитель-определитель `21 00 00 00`, где `0x21` это число **33**.

### Продолжение следует..
Но самое интересное еще впереди, однако, я еще не разобрался в том как именно формируется смещение до текстовых данных меж данными, чтобы хеш отсылал на строку, и потому не могу поделиться этими мыслями, но возможно всё измениться в скором времени, и я совершу новое открытие.


---
## Полная по-байтовая структура файла из примеров:
```
0E 14 74 75 67 4A 03 FC 4A 15 90 9D C3 37 7F 1B
01 7F 00 00 00 00 00 00 00 01 00 00 00 00 00 00
00 02 00 00 00 21 00 00 00 46 45 44 39 31 32 42 
44 34 44 34 31 41 37 34 36 33 46 46 44 38 32 42 
42 45 31 36 35 42 44 45 32 00 CE 2E C3 F0 00 00 
00 00 21 00 00 00 46 42 31 39 46 34 44 43 34 42 
35 30 43 33 43 43 39 36 37 35 35 44 42 41 32 34 
34 34 30 38 34 33 00 08 B6 A5 84 01 00 00 00 02 
00 00 00 47 00 00 00 41 6C 6C 6F 77 73 20 66 6F 
72 20 6F 70 65 6E 69 6E 67 20 61 6E 64 20 63 6C 
6F 73 69 6E 67 20 61 20 22 67 61 74 65 22 20 74 
6F 20 63 6F 6E 74 72 6F 6C 20 74 68 65 20 65 78 
65 63 75 74 69 6F 6E 20 66 6C 6F 77 2E 00 34 00 
00 00 41 6C 74 65 72 6E 61 74 65 73 20 62 65 74 
77 65 65 6E 20 41 20 61 6E 64 20 42 20 6F 75 74 
70 75 74 73 2C 20 73 74 61 72 74 69 6E 67 20 77 
69 74 68 20 41 00
```
Можете проверять мою теорию и размышления, и строить свои.